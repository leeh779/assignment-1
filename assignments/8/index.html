<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffer geometry constructed from geometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">
			import * as THREE from '/assets/three.module.js';
			import Stats from '/assets/stats.module.js';
			import { TrackballControls } from '/assets/controls/TrackballControls.js';
			var camera, scene, renderer, controls, stats;
			init();
			animate();

			//TEXT
			var loader = new THREE.FontLoader();
			loader.load( 'assets/gentilis_regular.typeface.json', function ( font ) {

				var cityArray = [ "Madagascar", "Santiago", "New York", "Los Angeles", "Tokyo", "London", "Berlin", "Amsterdam"]

				var textGeo = new THREE.TextGeometry ( cityArray[0], {
					font: font,
					size: 2,
					height: 0.1,
					bevelEnabled: false
				});
				var textMaterial = new THREE.MeshPhongMaterial( {color:0xffffff} );
				var mesh = new THREE.Mesh( textGeo, textMaterial );
				mesh.position.set( 30, 8, 20 );
				scene.add( mesh );
			});

			function init() {
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 45.0, window.innerWidth / window.innerHeight, 0.1, 1500.0 );
				// camera.position.z = 480.0;
				camera.position.set( 1,1,1 );
				scene.add( camera );
				controls = new TrackballControls( camera, renderer.domElement );
				controls.minDistance = 100.0;
				controls.maxDistance = 800.0;
				controls.dynamicDampingFactor = 0.1;
				scene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) );
				var light = new THREE.PointLight( 0xffffff, 0.7 );
				camera.add( light );
				createScene();
				stats = new Stats();
				document.body.appendChild( stats.dom );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			// create the Earth
			// Should be the same size with sphereShape.
			var geometry  = new THREE.SphereGeometry(29, 32, 32);
			var material  = new THREE.MeshBasicMaterial();
			// material.color = new THREE.Color ( 0x31b477 );
			// material.transparent = true;
			// material.blending = THREE.AdditiveBlending;
			var earthMesh = new THREE.Mesh(geometry, material)
			material.map  = THREE.ImageUtils.loadTexture('assets/imgs/earth-surface.png')
			
			scene.add(earthMesh);
			



			function createGeometry() {
				// option 2: convert heart geometry into circle and remove extrusion depth
				var sphereShape = new THREE.Shape();
				var x = 0, y = 0;
				sphereShape.ellipse ( 0, 0, x + 1, y + 1, 0, 270, false, 0 )

				var extrudeSettings = {
					depth: 1,
					bevelEnabled: false,
					// bevelSegments: 1,
					// steps: 2,
					// bevelSize: 1,
					// bevelThickness: 1
				};

				var geometry = new THREE.ExtrudeGeometry( sphereShape, extrudeSettings );
				geometry.rotateX( Math.PI );
				geometry.scale( 0.3, 0.3, 0.3 );
				return geometry;
			}
			function createScene() {
				var bufferGeometry = new THREE.BufferGeometry();
				var radius = 30;
				var count = 300;
				var positions = [];
				var normals = [];
				var colors = [];
				var vector = new THREE.Vector3();
				var color = new THREE.Color( 0xffffff );
				var heartGeometry = createGeometry();
				var geometry = new THREE.Geometry();
				//

				var runOneDot = function(i){
					
					var l = count;
					var phi = Math.acos( - 1 + ( 2 * i ) / l );
					var theta = Math.sqrt( l * Math.PI ) * phi;
					vector.setFromSphericalCoords( radius, phi, theta );
					geometry.copy( heartGeometry );
					geometry.lookAt( vector );
					geometry.translate( vector.x, vector.y, vector.z );
					// color.setHSL( ( i / l ), 1.0, 0.7 );
					// Sandstone: color.setHSL( 15, 17, 59 );
					color.setHSL( 14, .80, .66 );

					//Color for localstorage
					// RETRIEVE AND UPDATE VARIABLE:
					// if(localstorage.getItem('hslColor')){
					// // if we've saved the color use it

					// 	var hslColor = localstorage.getItem('hslColor');
					// 	// local storage saves strings, so any number or array we need to convert
					// 	hslColor = JSON.parse(hslColor); // convert string into readable array
					// 	color.setHSL(hslColor[0], hslColor[1], hslColor[2]);

					// }else{// use the default

					// 	var hslColors = [0, 0, .89]; //gray color
					// 	color.setHSL(hslColors[0], hslColors[1], hslColors[2]);
					// }



					// // SAVE VARIABLE: (happen on click or based off of time, etc)
					// var newHslColor = [14, .80, .66];
					// 	// update the actual color that's being seen

					// 	// update the local storage item:
					// 	// convert hsl array into string:
					// newHslColor = JSON.stringify(newHslColor); // "[1.5, 2.5, 3.5]"
					// // "this is a string"

					// localstorage.setItem('hslColor', newHslColor);
					//Color for localstorage END.


					// console.log(geometry.faces[0])

					console.log(geometry)

					geometry.faces.forEach( function ( face ) {
						console.log(face)
						positions.push( geometry.vertices[ face.a ].x );
						positions.push( geometry.vertices[ face.a ].y );
						positions.push( geometry.vertices[ face.a ].z );
						positions.push( geometry.vertices[ face.b ].x );
						positions.push( geometry.vertices[ face.b ].y );
						positions.push( geometry.vertices[ face.b ].z );
						positions.push( geometry.vertices[ face.c ].x );
						positions.push( geometry.vertices[ face.c ].y );
						positions.push( geometry.vertices[ face.c ].z );
						normals.push( face.normal.x );
						normals.push( face.normal.y );
						normals.push( face.normal.z );
						normals.push( face.normal.x );
						normals.push( face.normal.y );
						normals.push( face.normal.z );
						normals.push( face.normal.x );
						normals.push( face.normal.y );
						normals.push( face.normal.z );
						colors.push( color.r );
						colors.push( color.g );
						colors.push( color.b );
						colors.push( color.r );
						colors.push( color.g );
						colors.push( color.b );
						colors.push( color.r );
						colors.push( color.g );
						colors.push( color.b );
				})
			}

			runOneDot(64); //Sydney
			// if (i = 64) { color.setHSL(0, 0, .75); }

			runOneDot(98.9); //Madagascar
			runOneDot(54.4); //Santiago
			runOneDot(251.3); //New York
			runOneDot(230); //Los Angeles
			runOneDot(237.4);  //Tokyo
			runOneDot(268); //London
			runOneDot(267.5); //Berlin
			runOneDot(267.7); //Amsterdam


			var runOneText = function(i){
					
					var l = count;
					var phi = Math.acos( - 1 + ( 2 * i ) / l );
					var theta = Math.sqrt( l * Math.PI ) * phi;
					vector.setFromSphericalCoords( radius, phi, theta );
					geometry.copy( heartGeometry );
					geometry.lookAt( vector );
					geometry.translate( vector.x, vector.y, vector.z );
					// color.setHSL( ( i / l ), 1.0, 0.7 );
					// Sandstone: color.setHSL( 15, 17, 59 );
					color.setHSL( 14, .80, .66 );

					console.log(geometry)

					geometry.faces.forEach( function ( face ) {
						console.log(face)
						positions.push( geometry.vertices[ face.a ].x );
						positions.push( geometry.vertices[ face.a ].y );
						positions.push( geometry.vertices[ face.a ].z );
						positions.push( geometry.vertices[ face.b ].x );
						positions.push( geometry.vertices[ face.b ].y );
						positions.push( geometry.vertices[ face.b ].z );
						positions.push( geometry.vertices[ face.c ].x );
						positions.push( geometry.vertices[ face.c ].y );
						positions.push( geometry.vertices[ face.c ].z );
						normals.push( face.normal.x );
						normals.push( face.normal.y );
						normals.push( face.normal.z );
						normals.push( face.normal.x );
						normals.push( face.normal.y );
						normals.push( face.normal.z );
						normals.push( face.normal.x );
						normals.push( face.normal.y );
						normals.push( face.normal.z );
						colors.push( color.r );
						colors.push( color.g );
						colors.push( color.b );
						colors.push( color.r );
						colors.push( color.g );
						colors.push( color.b );
						colors.push( color.r );
						colors.push( color.g );
						colors.push( color.b );
				})
			}




				bufferGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				bufferGeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
				bufferGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				var material = new THREE.MeshPhongMaterial( { shininess: 1, vertexColors: THREE.VertexColors } );
				var mesh = new THREE.Mesh( bufferGeometry, material );
				scene.add( mesh );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				stats.update();
				renderer.render( scene, camera );
			}


		</script>
	</body>
</html>